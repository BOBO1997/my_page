---
sidebarDepth: 2
---

# TSPを解く動的計画法をGrover探索で加速する方法

::: tip 概要
この記事は、Andris Ambainis, Kaspars Balodis, J¯anis Iraids, Martins Kokainis, Kriˇsj¯anis Pr¯usis, and Jevg¯enijs Vihrovs が2018年に発表した、「Quantum Speedups for Exponential-Time Dynamic Programming Algorithms」という論文の、TSPに関する部分を抜き出して紹介したものです.

具体的には、一般の巡回セールスマン問題を正確に解く古典アルゴリズムで知られている中で最も速い、動的計画法を用いた$O(n^22^n)$時間のアルゴリズムを、Grover探索を使って$O^*(1.7274^n)$時間に加速する方法を紹介します.
:::

## [古典アルゴリズム]---TSPを動的計画法で解く方法

巡回セールスマン問題(Traveling Salesman Problem, TSP)とは以下のような問題です.
::: tip 巡回セールスマン問題
- INPUT : 重み付き無向グラフ$G = (V, E)$ (つまり、$n$個の頂点$v_1, \cdots, v_n$と、各頂点間の距離(コスト)関数)
- OUTPUT : 各頂点をちょうど一度ずつ巡るループの中でコストが最も小さいもの(のコスト)
:::

::: warning 言葉の定義
- $O^*(f(n)) := O(f(n){\rm poly}(n))$
- $N(v)$ : グラフの頂点$v$と辺を共有している頂点の集合(頂点$v$自身は含まれない)
- ハミルトン路 : グラフ上の全ての頂点をちょうど1度ずつ通る路(パス)
:::

まず、有名な動的計画法を載せておきます.

::: tip
Bellman–Held–Karpのアルゴリズム(1962)
:::

お気持ちとしては、全探索すると$O(n!)$時間かかるので、せめて$O^*(2^n)$とかに抑えられないかと、動的計画法を駆使します.
具体的には、$G$の頂点集合$V$のすべての部分集合$S$が$2^n$個しかないこと、新しい部分集合$S$内における最適なコストを求めたい時、既に部分的に最適なコストが求まっている部分集合たちを多項式時間のオーバーヘッドで再利用できることに注目します.
アルゴリズムとしては、$S$のサイズについて、これを一つずつ大きくしていきます.
ループを見つけたいということなので、ループの基点を一つ固定して(なんでもいいので例えば$v_1$)、頂点の部分集合について以下のようにコストを定義します.

- $OPT[v, S]$ : 頂点$v_1$から出発して部分集合$S$の頂点をハミルトン路で巡った後に頂点$v$にたどり着く時の最適なコスト

この時、求めたいものは、$OPT[v,V-\{v_1\}] + d(v,v_1)$の中で、最小のものになります. (基点$v_1$を除いた部分集合を回った後、基点に戻るパスの中でコスト最小のもの)

以下は擬似コードです.
```python
for i in (1 , ... , n) :
	OPT[v_i, {v_i}] = d(v_1, v_i)
for j in (1 , ... , n-1) :
	forall subset S of {v_2, ..., v_n} satisfying |S| = j :
		for i in (2 , ... , n) : 
			OPT[v_i, S] = min( OPT[v_i, S\{v_k}] + d(v_i, v_k); for v_k in S\{v_i} )
return min(OPT[v_i, V\{v_1}] + d(v_1, v_i); for v_i in V\{v_1})
```

このアルゴリズムの計算量は$j$のループに$n$、その中で部分集合$S$を全て探索しているので$2^n$、さらにそれぞれの部分集合について全要素を調べるのに$i$でループを回しているので$n$、よって、全体では$O(n^22^n)$時間になります.

上で挙げた$OPT$についてその変数として始点も与え、以下のように定義し直してみましょう.

- $OPT[s, t, S]$ : 頂点$s\in S$から出発し、部分集合$S$の頂点をちょうど1度ずつ通り、頂点$t\in S$にたどり着くパスにおける最小のコスト

この時$OPT[s, t, S]$の計算方法は、

$OPT[s,t,S] = min(OPT[s, u, S-\{t\}] + d(u, t)),\ for\ u\in N(t)\cap S$

となります. 
この更新式を「古典の部分問題の計算方法」と呼ぶことにします.
ここで、部分集合$S$について、$k\in{2,\cdots,|S|-1}$を定数(例えば操作としては半分に問題を分けるなど)として、上の計算方法は次のようにも書くことができます.
これ(以下の更新式)を「部分問題の計算方法」と呼ぶことにします.

$OPT[s,t,S] = \underset{s\in X, t\notin X, |X| = k}{min}\ \underset{u\in X-\{s\}}{min}(OPT[s, u, X] + OPT[u, t, (S-X)\cup\{u\}])$

これは、集合$S$を大きさが$k$の部分集合$X\subset S$と$S-X$に分け、$s\in X$から出発して$u\in X$に終わるコスト最小のハミルトン路と、$u\in (S-X)\cup\{u\}$から出発して$t\in S-X$に終わるコスト最小のハミルトン路をつなげたものの中でコスト最小のものを選べ良いという発想です. 

この発想に基づくと、上で与えたTSPの解を求める動的計画法は見方を少し変えれば以下の解き方と同じです.
これ(以下の更新式)を「全体の計算方法」と呼ぶことにします.

$OPT = \underset{S\subset V, |S| = \frac n 2}{min}\ \underset{s,t\in S, s\neq t}{min}(OPT[s, t, S] + OPT[s, t, (V-S)\cup\{s,t\}])$

つまり、まず全体のグラフを二つの部分グラフに分割することを考えます.
そして、元のグラフでのハミルトン閉路について、2つの部分グラフの境界となる点を2つ選んで固定し、それらを短点とするそれぞれの部分グラフの点を1度ずつ通る2つのパスに分けます. 
このパスについてもそれぞれの部分グラフ内で最適コストを計算して、最後に固定した2点でつなげて閉路にした時にコスト最小となるものを選べば答えが出る、という考え方です.


## [量子アルゴリズム]---古典アルゴルリズムの一部分にGrover探索を用いる

この考え方に基づくと、$OPT$を計算するのにどのような二等分$S, V-S$についても値$OPT[s,t,S]$がわかっていなければならないわけですが、$OPT[s,t,S]$を知るにはより小さな$OPT[s,u,X]$などを求めておく必要があります.
ここで、上の$k$を$\frac {|S|} 2$として、問題を次々2分割するのも良いのですが、分割の段階が多くなる分、小さくわけられた問題の数も指数的に増えます. 原論文ではこの段階を3段階でとどめ、3段階目は正確に二等分するのではなく、パラメタ$\alpha$を用いて分割の調整を行なっています.(テイラー展開の打ち切った部分の処理とお気持ちが似てる...?)

::: tip 分割の段階(深さ)
1. 全体の問題の最適解を「全体の計算方法」を使って求めるにあたって、$V$を$S$と$V-S$に二等分する. つまり、サイズ$\frac n 2$の部分問題に分ける.
2. 1.で2等分したサイズ$\frac n 2$の部分問題の最適解を「部分問題の計算方法」を使って求めるにあたって、これをさらに2等分する. つまり、サイズ$\frac n 4$の部分問題にする.
3. 2.で2等分したサイズ$\frac n 4$の部分問題の最適解を「部分問題の計算方法」を使って求めるにあたって、これをパラメタ$0<\alpha<\frac 1 2$を使って、サイズ$\frac {\alpha n} 4$とサイズ$\frac {(1-\alpha)n} 4$の部分問題に分割する.
4. (ここが古典で準備する部分) 「古典の部分問題の計算方法」の計算方法を使って、動的計画法の表を大きさ$\frac {(1-\alpha)n} 4$のものまで計算する.
:::

実行する順序は4, 3, 2, 1の順に計算していけば良い.

それぞれの段階を計算する方法
- 段階3では最大でサイズ$\frac {(1-\alpha)n} 4$の部分問題を計算することになるから、ここを古典アルゴリズムで動的計画法を回し、サイズ$\frac {(1-\alpha)n} 4$の部分集合までの解を全て保持しておく.
そして、パラメタ$\alpha$に従ってサイズ$\frac {(\alpha n)} 4$と$\frac {(1-\alpha)n} 4$に分割したものを用いて、「部分問題の計算方法」をGrover探索によって計算する. 
こうしてサイズ$\frac n 4$の部分問題の最適解を得ることができた.
- 段階2では、段階3で得たサイズ$\frac n 4$の部分問題を用いて、「部分問題の計算方法」をGrover探索によって計算し、サイズ$\frac n 2$の部分問題の最適解を得る.
- 最後に段階1で、サイズ$\frac n 2$の部分問題を用いて、「全体の計算方法」をGrover探索によって計算し、全体のグラフでの最適なコストが求まる.


## 計算量の解析

古典部分の計算量は、

<!--
$\displaystyle O\left(\left(\frac {(1-\alpha)n} 4\right)^22^{\frac {(1-\alpha)n} 4}\right)$
$\displaystyle O\left(\sum_{i=0}^{\frac {(1-\alpha)n} 4}\left(\begin{array}{cc}n\\ i\end{array}\right)\right)$
-->

![tex](/my_page/articles/tsp_by_grover/classical_complexity.png)

ただし、$H(p)$はバイナリエントロピーとします.

量子部分の計算量は、それぞれの段階のGrover探索による探索時間について考えると、

![tex](/my_page/articles/tsp_by_grover/quantum_complexity.png)

全体の計算量はこれらの和ですが、古典部分の計算量には$H(1-\alpha)$の項が、量子部分の計算量には$H(\alpha)$の項が存在していることに注意すると、全体の計算時間を最小にするように古典パートと量子パートをバランスするような$\alpha$が存在することになります.
ここで、全体の計算時間を最小にするような$\alpha$を求めると、このような$\alpha$の値は$\alpha = 0.0554$程度とわかります.

::: tip
このアルゴリズムは「いい具合に」BHK動的計画法による寄与とGrover探索による寄与をハイブリッドしたと言えるでしょう. 

完全にGrover探索をすると、$O(\sqrt{n!})$時間だし、完全な古典的な動的計画法だと$O^*(2^n)$時間かかる. でも、うまい具合に組み合わせると、$O^*(1.7274^n)$時間のアルゴリズムを作ることができる!!
:::

## 参考文献

- Ambainis, Andris, et al. "Quantum speedups for exponential-time dynamic programming algorithms." Proceedings of the Thirtieth Annual ACM-SIAM Symposium on Discrete Algorithms. Society for Industrial and Applied Mathematics, 2019.
- [Exact Exponential Algorithms](https://www.springer.com/jp/book/9783642165320), 学内無料、なお、ネットに[pdf](http://www.ii.uib.no/~fomin/BookEA/BookEA.pdf)が落ちてる

